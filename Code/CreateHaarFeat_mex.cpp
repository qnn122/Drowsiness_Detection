/******************************************************************************
 * Function MEX-File: CreateHaarFeat_mex.cpp
 *
 * Purpose:
 *		Function CREATEHAARFEAT generates a feature matrix in which each row
 *		represents a sample and each sample is characterized by a combination
 *		of feature values. Each column represents a feature determined by a
 *		combination of window WIDTH and window LENGTH (winWidth and winLength,
 *		respectively). The values of these 2 parameters are generated randomly
 *
 * Record of revision:
 *		Date			Description of change
 *	   ======			=====================
 *	   10/08/14			Original code
 *
 * Define variables:
 *      coord       -- <n x 2> matrix, stores desired pixel's coordinates
 *      im          -- gray scale image
 *      num_feat    -- number of feature, should be divisible by 5(5 feat types)
 *		featPara	-- feature parameters, characterized by combinations of wL and wW
 *      featMat     -- feature matrix generated by Haar features
 *
 * Example:
 *	featMat = CreateHaarFeat_mex(img, coord, feature);
 *
 * Author: Quang Nguyen
 ******************************************************************************/

#include <mex.h>
#include <matrix.h>
#include <math.h>
#include <stdio.h>

double CalcIntRec(double *img, double *fourpoints);
double HaarFeatureCalc(double *img, double x, double y, double winWidth, double winLength, double classifier);

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
// Declare variables
	mxArray *img_m, *coord_m, *featPa_m;		// input matrix
	mxArray *featMat_m;							// ouput matrix (in this case, a single value actually)
	double	*featMat, *img, *coord, *featPa;	// associate input and output pointers
    const mwSize *dims;				// used to extract dims of input
	int img_dimy,	 img_dimx;		// dims of image
	int coord_dimy,  coord_dimx;	// dims of coord
	int featPa_dimy, featPa_dimx;	// dims of given feature
	int i, j;						// for iteration

// Dimension of the given image
	dims = mxGetDimensions(prhs[0]);	img_dimy = (int)dims[0];	img_dimx = (int)dims[1];

// Dimension of the coordinate matrix
	dims = mxGetDimensions(prhs[1]);	coord_dimy = (int)dims[0];	coord_dimx = (int)dims[1];

// Dimension of the give feature parameters
	dims = mxGetDimensions(prhs[2]);	featPa_dimy = (int)dims[0];	featPa_dimx = (int)dims[1];

// associate outputs
	featMat_m = plhs[0] = mxCreateDoubleMatrix(coord_dimy, featPa_dimy, mxREAL);	// <numSample x numFeat>

// Associate inputs
	img_m = mxDuplicateArray(prhs[0]);
	coord_m = mxDuplicateArray(prhs[1]);
	featPa_m = mxDuplicateArray(prhs[2]);

// Associate pointers
	featMat = mxGetPr(featMat_m);
	img = mxGetPr(img_m);
	coord = mxGetPr(coord_m);
    featPa = mxGetPr(featPa_m);

	double winWidth, winLength;
	double x, y, result;


// Send samples to Haar features
	for (i=0; i<featPa_dimy; i++) {
		winLength = featPa[i]; winWidth = featPa[featPa_dimy + i];
		for (j=0; j<coord_dimy; j++) {
			x = coord[j]; y = coord[coord_dimy + j];
			//printf("x y = %f %f\n", x, y);
			if ( (x<2)||(y<2)||((img_dimy - y) < winLength)||((img_dimx - x) < winWidth) ) { // boundaries to be able to calc haar feat
				featMat[i*coord_dimy + j] = 0;
				continue;
			}
		// call the function
			result = HaarFeatureCalc(img, y, x, winWidth, winLength, ceil(double(5*i/featPa_dimy))+1);
			featMat[i*coord_dimy + j] = result;
		} // j loop
	} // i loop
}

double CalcIntRec(double *img, double *fourpoints) {
    int row_val = (int)fourpoints[0]-1;
    int col_val = (int)fourpoints[1]-1;
    int img_width = (int)fourpoints[2];
    int img_length = (int)fourpoints[3];
    int dimy = 128;
    double one, two, three, four, result;

    one = img[row_val-1 + (col_val-1)*dimy];
    two = img[row_val-1 + (col_val + img_width)*dimy];
    three = img[row_val + img_length + (col_val-1)*dimy];
    four = img[row_val + img_length + (col_val + img_width)*dimy];

    result = four + one - (two + three);
    return result;
}

double HaarFeatureCalc(double *img, double x, double y, double winWidth, double winLength, double classifier) {
    double firstRec[4], secondRec[4], thirdRec[4], fourthRec[4];
    double rec1, rec2, rec3, rec4, result;
    switch ((int)classifier) {
    case 1:
        firstRec[0] = x;	firstRec[1] = y;				firstRec[2] = winWidth/2-1;		firstRec[3] = winLength -1;
		secondRec[0] = x;	secondRec[1] = y + winWidth/2;	secondRec[2] = winWidth/2-1;	secondRec[3] = winLength -1;

        rec1 = CalcIntRec(img, firstRec); rec2 = CalcIntRec(img, secondRec);
        result = rec1 - rec2;
        break;
    case 2:
        firstRec[0] = x;				firstRec[1] = y;	firstRec[2] = winWidth-1;	firstRec[3] = winLength/2 -1;
		secondRec[0] = x+winLength/2;	secondRec[1] = y;	secondRec[2] = winWidth-1;	secondRec[3] = winLength/2 -1;

        rec1 = CalcIntRec(img, firstRec); rec2 = CalcIntRec(img, secondRec);
        result = rec1 - rec2;
    case 3:
        firstRec[0] = x;	firstRec[1] = y;				firstRec[2] = winWidth/3-1;		firstRec[3] = winLength -1;
		secondRec[0] = x;	secondRec[1] = y + winWidth/3;	secondRec[2] = winWidth/3-1;	secondRec[3] = winLength -1;
		thirdRec[0] = x;	thirdRec[1] = y + 2*winWidth/3; thirdRec[2] = winWidth/3-1;		thirdRec[3] = winLength -1;

        rec1 = CalcIntRec(img, firstRec); rec2 = CalcIntRec(img, secondRec); rec3 = CalcIntRec(img, thirdRec);
        result = rec1 - rec2 + rec3;
        break;
    case 4:
        firstRec[0] = x;				firstRec[1] = y;	firstRec[2] = winWidth-1;	firstRec[3] = winLength/3 -1;
		secondRec[0] = x + winLength/3; secondRec[1] = y;	secondRec[2] = winWidth-1;	secondRec[3] = winLength/3 -1;
		thirdRec[0] = x+2*winLength/3;	thirdRec[1] = y;	thirdRec[2] = winWidth-1;	thirdRec[3] = winLength/3 -1;

        rec1 = CalcIntRec(img, firstRec); rec2 = CalcIntRec(img, secondRec); rec3 = CalcIntRec(img, thirdRec);
        result = rec1 - rec2 + rec3;
        break;
	case 5:
        firstRec[0] = x;			  firstRec[1] = y;				 firstRec[2] = winWidth/2-1;  firstRec[3] = winLength/2 -1;
		secondRec[0] = x;			  secondRec[1] = y + winWidth/2; secondRec[2] = winWidth/2-1; secondRec[3] = winLength/2 -1;
		thirdRec[0] = x+winLength/2;  thirdRec[1] = y;				 thirdRec[2] = winWidth/2-1;  thirdRec[3] = winLength/2 -1;
		fourthRec[0] = x+winLength/2; fourthRec[1] = y + winWidth/2; fourthRec[2] = winWidth/2-1; fourthRec[3] = winLength/2 -1;

        rec1 = CalcIntRec(img, firstRec); rec2 = CalcIntRec(img, secondRec);
        rec3 = CalcIntRec(img, thirdRec); rec4 = CalcIntRec(img, fourthRec);
        result = rec1 - rec2 + rec3 - rec4;
        break;
    default:
		printf("Error: wrong classifier type !\n");
    }
    return result;
}
