/******************************************************************************
 * Function MEX-File: CreatePosiFeat_mex.cpp
 *
 * Purpose:
 *		Function CREATEHAARFEAT generates a feature matrix in which each row
 *		represents a sample and each sample is characterized by a combination
 *		of feature values. Each column represents a feature determined by a
 *		combination of A and B (horizontal and vertical distance,
 *		respectively). The values of these 2 parameters are generated randomly
 *
 * Record of revision:
 *		Date			Description of change
 *	   ======			=====================
 *	   10/08/14			Original code
 *
 * Define variables:
 *      coord       -- <n x 2> matrix, stores desired pixel's coordinates
 *      im          -- gray scale img
 *      num_feat    -- number of feature, should be divisible by 5(5 feat types)
 *		featPara	-- feature parameters, characterized by combinations of wL and wW
 *      featMat     -- feature matrix generated by Haar features
 *
 * Example:
 *	featMat = CreatePosiFeat_mex(img, coord, posifeature);
 *
 * Author: Quang Nguyen
 ******************************************************************************/

#include <mex.h>
#include <matrix.h>
#include <stdio.h>
#include <math.h>

double GetMax(double *array, int size);
double GetMin(double *array, int size);

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
// Declare variables
	mxArray *img_m, *coord_m, *featPa_m;		// input matrix
	mxArray *featMat_m;							// ouput matrix (in this case, a single value actually)
	double	*featMat, *img, *coord, *featPa;	// associate input and output pointers
    const mwSize *dims;				// used to extract dims of input
	int img_dimy,	 img_dimx;		// dims of img
	int coord_dimy,  coord_dimx;	// dims of coord
	int featPa_dimy, featPa_dimx;	// dims of given feature
	int i, j;						// for iteration

// Dimension of the given img
	dims = mxGetDimensions(prhs[0]);	img_dimy = (int)dims[0];	img_dimx = (int)dims[1];

// Dimension of the coordinate matrix
	dims = mxGetDimensions(prhs[1]);	coord_dimy = (int)dims[0];	coord_dimx = (int)dims[1];

// Dimension of the give feature parameters
	dims = mxGetDimensions(prhs[2]);	featPa_dimy = (int)dims[0];	featPa_dimx = (int)dims[1];

// associate outputs
	featMat_m = plhs[0] = mxCreateDoubleMatrix(coord_dimy, featPa_dimy, mxREAL);	// <numSample x numFeat>

// Associate inputs
	img_m = mxDuplicateArray(prhs[0]);
	coord_m = mxDuplicateArray(prhs[1]);
	featPa_m = mxDuplicateArray(prhs[2]);

// Associate pointers
	featMat = mxGetPr(featMat_m);
	img = mxGetPr(img_m);
	coord = mxGetPr(coord_m);
    featPa = mxGetPr(featPa_m);

	double a, b;
	double x, y;
    double down = GetMin(coord, coord_dimy); // collect max and min values in ONE COLUMN
    double up   = GetMax(coord, coord_dimy);
    double exp = up - down;
    //printf("down, up, exp = %d %d %d\n", (int)down, (int)up, (int)exp);

// Send samples to Haar features
	for (i=0; i<featPa_dimy; i++) {
		//a = floor(featPa[i]/128*exp); b = floor(featPa[featPa_dimy + i]/128*exp);
		a = featPa[i]; b = featPa[featPa_dimy + i];
        for (j=0; j<coord_dimy; j++) {
			x = coord[j]-1; y = coord[coord_dimy + j]-1;
			if ((x - a < down)||(x + a > up )||(y - b < down)||(y + b > up)||(x + a < down)||(x - a > up )||(y + b < down)||(y - b > up)) {
                featMat[i*coord_dimy + j] = 0;
                continue;
            }
            featMat[i*coord_dimy + j] = img[(int)(x - a + (y - b)*128)] - img[(int)(x + a + (y + b)*128)];
		} // j loop
	} // i loop
}

double GetMax(double *array, int size) {
    int iMax = 0;
    for (int i = 1; i < size; ++i) {
        if (array[i] > array[iMax]) {
            iMax = i;
        }
    }
    return array[iMax];
}

double GetMin(double *array, int size) {
    int iMin = 0;
    for (int i = 0; i < size; ++i) {
        if (array[i] < array[iMin]) {
            iMin = i;
        }
    }
    return array[iMin];
}


